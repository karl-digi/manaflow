"use node";
import { createAnthropic } from "@ai-sdk/anthropic";
import { createOpenAI } from "@ai-sdk/openai";
import { generateObject, type LanguageModel } from "ai";
import { v } from "convex/values";
import { z } from "zod";
import { CLOUDFLARE_OPENAI_BASE_URL } from "@cmux/shared";
import { fetchInstallationAccessToken } from "../_shared/githubApp";
import { env } from "../_shared/convex-env";
import { internal } from "./_generated/api";
import type { Doc, Id } from "./_generated/dataModel";
import {
  internalAction,
  type ActionCtx,
} from "./_generated/server";
import { Octokit } from "octokit";

const CMUX_BASE_URL = "https://cmux.sh";
const COMMENT_SIGNATURE = `_Generated by [cmux](${CMUX_BASE_URL})`;
const COMMENT_SIGNATURE_MATCHERS = [
  COMMENT_SIGNATURE,
  "_Generated by [cmux](https://cmux.dev)",
];
const PREVIEW_SIGNATURE = `_Generated by [cmux](${CMUX_BASE_URL}) preview system_`;

const createOctokit = (token: string): Octokit => {
  return new Octokit({
    auth: token,
    userAgent: "cmux-github-bot",
    request: {
      timeout: 10_000,
    },
  });
};

const parseRepoFullName = (
  repoFullName: string,
): { owner: string; repo: string } | null => {
  const [owner, repo] = repoFullName.split("/");
  if (!owner || !repo) {
    return null;
  }
  return { owner, repo };
};

type PreviewRunDoc = Doc<"previewRuns">;
type ScreenshotSetDoc = Doc<"previewScreenshotSets">;
type RenderableScreenshotSet = {
  status: ScreenshotSetDoc["status"];
  commitSha?: string | null;
  capturedAt?: number | null;
  error?: string | null;
  images: Array<{
    storageId: Id<"_storage">;
    mimeType: string;
    fileName?: string;
    commitSha?: string;
    width?: number;
    height?: number;
  }>;
};

const PREVIEW_OPENAI_MODEL = "gpt-5-mini";
const PREVIEW_ANTHROPIC_MODEL = "claude-3-5-sonnet-20241022";

const PreviewNarrativeSchema = z.object({
  headline: z.string().optional(),
  story: z.array(z.string()).min(1).optional(),
  reviewFocus: z.array(z.string()).min(1).optional(),
  risks: z.array(z.string()).optional(),
  testIdeas: z.array(z.string()).optional(),
  imageCaptions: z.array(z.string()).optional(),
});

type PreviewNarrative = z.infer<typeof PreviewNarrativeSchema>;

const COLLAPSE_MARKER = "<!-- cmux-preview-collapsed -->";
const COLLAPSE_SUMMARY = "Older cmux preview screenshots (latest comment is above)";
const MAX_COMMENTS_TO_COLLAPSE = 20;
const MAX_PREVIOUS_SCREENSHOT_SETS = 5;
const NON_UI_CHANGE_PATTERNS = [
  /no changes detected/i,
  /all changed files are binary/i,
];
const STATUS_SUMMARY_LABEL: Record<ScreenshotSetDoc["status"], string> = {
  completed: "✅ Screenshots",
  failed: "❌ Failed",
  skipped: "⚠️ Skipped",
};
const MAX_FILES_FOR_NARRATIVE = 40;
const MAX_PR_BODY_CHARS = 2_500;

function resolvePreviewModel(): {
  provider: "openai" | "anthropic";
  model: LanguageModel;
} {
  const openaiKey = env.OPENAI_API_KEY;
  if (openaiKey) {
    const openai = createOpenAI({
      apiKey: openaiKey,
      baseURL: CLOUDFLARE_OPENAI_BASE_URL,
    });
    return { provider: "openai", model: openai(PREVIEW_OPENAI_MODEL) };
  }

  const anthropicKey = env.ANTHROPIC_API_KEY;
  if (anthropicKey) {
    const anthropic = createAnthropic({ apiKey: anthropicKey });
    return { provider: "anthropic", model: anthropic(PREVIEW_ANTHROPIC_MODEL) };
  }

  throw new Error(
    "Preview narrative generation is not configured (missing OpenAI or Anthropic API key)",
  );
}

const formatPrBody = (body?: string | null): string => {
  if (!body) return "";
  const trimmed = body.trim();
  if (trimmed.length <= MAX_PR_BODY_CHARS) return trimmed;
  return `${trimmed.slice(0, MAX_PR_BODY_CHARS)}…`;
};

async function fetchPrContext({
  octokit,
  owner,
  repo,
  prNumber,
  commitSha,
}: {
  octokit: Octokit;
  owner: string;
  repo: string;
  prNumber: number;
  commitSha?: string | null;
}): Promise<{
  title?: string;
  body?: string;
  changedFiles: string[];
  headRef?: string;
  commitMessage?: string;
}> {
  let title: string | undefined;
  let body: string | undefined;
  let headRef: string | undefined;
  let commitMessage: string | undefined;
  const changedFiles: string[] = [];

  try {
    const { data } = await octokit.rest.pulls.get({
      owner,
      repo,
      pull_number: prNumber,
    });
    title = data.title;
    body = data.body ?? undefined;
    headRef = data.head?.ref;
  } catch (error) {
    console.warn("[github_pr_comments] Failed to fetch PR metadata", {
      owner,
      repo,
      prNumber,
      error,
    });
  }

  try {
    const files = await octokit.paginate(octokit.rest.pulls.listFiles, {
      owner,
      repo,
      pull_number: prNumber,
      per_page: 100,
    });
    for (const file of files.slice(0, MAX_FILES_FOR_NARRATIVE)) {
      const status = file.status ? ` (${file.status})` : "";
      const additions =
        typeof file.additions === "number" && file.additions > 0
          ? ` +${file.additions}`
          : "";
      const deletions =
        typeof file.deletions === "number" && file.deletions > 0
          ? ` -${file.deletions}`
          : "";
      const changeSummary =
        additions || deletions ? `${additions}${deletions}` : "";
      changedFiles.push(`${file.filename}${status}${changeSummary ? ` [${changeSummary}]` : ""}`);
    }
  } catch (error) {
    console.warn("[github_pr_comments] Failed to fetch PR files", {
      owner,
      repo,
      prNumber,
      error,
    });
  }

  if (commitSha) {
    try {
      const { data } = await octokit.rest.repos.getCommit({
        owner,
        repo,
        ref: commitSha,
      });
      commitMessage = data.commit?.message;
    } catch (error) {
      console.warn("[github_pr_comments] Failed to fetch commit message", {
        owner,
        repo,
        commitSha,
        error,
      });
    }
  }

  return {
    title,
    body: formatPrBody(body),
    changedFiles,
    headRef,
    commitMessage,
  };
}

async function generatePreviewNarrative({
  screenshotSet,
  prContext,
  prUrl,
  workspaceUrl,
}: {
  screenshotSet: RenderableScreenshotSet;
  prContext: Awaited<ReturnType<typeof fetchPrContext>>;
  prUrl?: string | null;
  workspaceUrl?: string | null;
}): Promise<PreviewNarrative | null> {
  try {
    const { model, provider } = resolvePreviewModel();
    const fileList =
      prContext.changedFiles.length > 0
        ? prContext.changedFiles.map((f, idx) => `${idx + 1}. ${f}`).join("\n")
        : "No file list available.";
    const screenshotCount = screenshotSet.images.length;
    const prompt = `You are drafting a short code review guide for a PR with captured UI screenshots.

PR Title: ${prContext.title ?? "unknown"}
Head branch: ${prContext.headRef ?? "unknown"}
Commit for screenshots: ${screenshotSet.commitSha ?? "unknown"}
Commit message: ${prContext.commitMessage ?? "n/a"}
PR URL: ${prUrl ?? "n/a"}
Workspace URL: ${workspaceUrl ?? "n/a"}

PR Summary (body):
${prContext.body ?? "<empty>"} 

Changed files (truncated):
${fileList}

Screenshot context:
- Count: ${screenshotCount}
- Captured at: ${formatTimestamp(screenshotSet.capturedAt)}

Write actionable bullets that help a human reviewer:
- Focus on what the PR is trying to achieve, based on the title/body/files.
- Call out specific review hotspots or risky areas.
- If applicable, suggest quick test or verification steps a reviewer can perform.
- Keep bullets tight and concrete; avoid filler.
- Do not invent details that aren't implied by the context above.

Respond as JSON matching this schema:
{
  "headline": optional short string,
  "story": required array of bullet strings (what changed, user impact),
  "reviewFocus": required array of bullet strings (what to inspect closely),
  "risks": optional array of bullet strings,
  "testIdeas": optional array of bullet strings,
  "imageCaptions": optional array of strings (one per screenshot, concise alt text without referencing filenames)
}
`;

    const { object } = await generateObject({
      model,
      schema: PreviewNarrativeSchema,
      system:
        "You are an expert reviewer. Stay concise and actionable. Prefer specific file or area names when available. Never add Markdown headers or code fences; return JSON only.",
      prompt,
      ...(provider === "openai" ? {} : { temperature: 0 }),
      maxRetries: 2,
    });

    return object;
  } catch (error) {
    console.warn("[github_pr_comments] Failed to generate preview narrative", {
      error,
    });
    return null;
  }
}

const formatTimestamp = (value?: number | null): string => {
  if (!value) {
    return "unknown time";
  }
  return new Date(value).toISOString().replace("T", " ").replace("Z", " UTC");
};

const formatCommitLabel = (set: RenderableScreenshotSet): string =>
  set.commitSha ? `\`${set.commitSha.slice(0, 7)}\`` : "latest commit";

const formatReviewLinks = ({
  prUrl,
  workspaceUrl,
  workspaceLabel = "Open Workspace",
  prLabel = "Open in GitHub",
}: {
  prUrl?: string | null;
  workspaceUrl?: string | null;
  workspaceLabel?: string;
  prLabel?: string;
}): string | null => {
  const links: string[] = [];
  if (workspaceUrl) {
    links.push(`[${workspaceLabel}](${workspaceUrl})`);
  }
  if (prUrl) {
    links.push(`[${prLabel}](${prUrl})`);
  }
  return links.length > 0 ? links.join(" • ") : null;
};

const isNonUiChangeReason = (reason?: string | null): boolean => {
  if (!reason) {
    return false;
  }
  return NON_UI_CHANGE_PATTERNS.some((pattern) => pattern.test(reason));
};

const formatSkippedMessage = (reason?: string | null): string => {
  if (isNonUiChangeReason(reason)) {
    return [
      "No UI-impacting changes were detected, so screenshots were skipped.",
      reason ? `> ${reason}` : null,
    ]
      .filter(Boolean)
      .join("\n\n");
  }
  if (reason) {
    return `Screenshot capture was skipped.\n\n> ${reason}`;
  }
  return "Screenshot capture was skipped.";
};

const summarizeSet = (
  set: ScreenshotSetDoc,
  run?: PreviewRunDoc,
): string => {
  const prefix = STATUS_SUMMARY_LABEL[set.status] ?? "ℹ️ Preview";
  const commit = set.commitSha ? set.commitSha.slice(0, 7) : "unknown";
  const timestamp = formatTimestamp(set.capturedAt ?? run?.createdAt);
  return `${prefix} – commit ${commit} (${timestamp})`;
};

async function renderScreenshotSetMarkdown(
  ctx: ActionCtx,
  set: RenderableScreenshotSet,
  heading: string,
  options?: {
    prUrl?: string | null;
    workspaceUrl?: string | null;
    compact?: boolean;
    includeLinksRow?: boolean;
    narrative?: PreviewNarrative | null;
  },
): Promise<string> {
  const commitLabel = formatCommitLabel(set);
  const timestamp = formatTimestamp(set.capturedAt);
  const lines: string[] = [heading, ""];
  const linkRow = options?.includeLinksRow
    ? formatReviewLinks({
        prUrl: options.prUrl,
        workspaceUrl: options.workspaceUrl,
      })
    : null;

  if (linkRow) {
    lines.push(linkRow, "");
  }

  if (set.status === "completed" && set.images.length > 0) {
    const count = set.images.length;
    const intro = `Captured ${count} screenshot${count === 1 ? "" : "s"} for commit ${commitLabel} (${timestamp}).`;
    lines.push(intro, "");

    if (!options?.compact) {
      const narrative = options?.narrative;
      const storyLines = (narrative?.story ?? []).filter(Boolean);
      const focusLines = (narrative?.reviewFocus ?? []).filter(Boolean);
      const riskLines = (narrative?.risks ?? []).filter(Boolean);
      const testLines = (narrative?.testIdeas ?? []).filter(Boolean);

      if (narrative?.headline) {
        lines.push(`**${narrative.headline}**`, "");
      }

      if (storyLines.length > 0) {
        lines.push("**Story**", ...storyLines.map((item) => `- ${item}`), "");
      }

      if (focusLines.length > 0) {
        lines.push(
          "**Review focus**",
          ...focusLines.map((item) => `- ${item}`),
          "",
        );
      }

      if (riskLines.length > 0) {
        lines.push(
          "**Risks / unknowns**",
          ...riskLines.map((item) => `- ${item}`),
          "",
        );
      }

      if (testLines.length > 0) {
        lines.push("**Test / verify**", ...testLines.map((item) => `- ${item}`), "");
      }

      if (
        !narrative ||
        (storyLines.length === 0 &&
          focusLines.length === 0 &&
          riskLines.length === 0 &&
          testLines.length === 0)
      ) {
        // Fallback guidance when LLM output is unavailable
        lines.push(
          "**Review focus**",
          "- Walk through the screenshots in order; they capture the latest UI flow.",
          options?.prUrl ? `- Cross-check intent against the PR description (${options.prUrl}).` : "- Cross-check intent against the PR description.",
          options?.workspaceUrl
            ? "- Use the workspace link to reproduce the flow and validate interactions."
            : "- Re-run the flow locally to validate interactions.",
          "",
        );
      }

      lines.push(
        `**Evidence (${count})**`,
        "",
      );
    } else {
      lines.push(`**Evidence (${count})**`, "");
    }

    const imageCaptions = options?.narrative?.imageCaptions ?? [];
    for (const [index, image] of set.images.entries()) {
      const storageUrl = await ctx.storage.getUrl(image.storageId);
      if (!storageUrl) continue;
      const altFromNarrative = imageCaptions[index]?.trim();
      const altText =
        altFromNarrative && altFromNarrative.length > 0
          ? altFromNarrative
          : `Screenshot ${index + 1} for ${commitLabel}`;
      lines.push(`![${altText}](${storageUrl})`, "");
    }
  } else if (set.status === "failed") {
    lines.push(
      `Failed to capture screenshots for commit ${commitLabel}.`,
      "",
      set.error ? `> ${set.error}` : "> Unknown error",
      "",
    );
  } else if (set.status === "skipped") {
    lines.push(formatSkippedMessage(set.error), "");
  } else {
    lines.push("Screenshot status is unknown for this run.", "");
  }

  return lines.join("\n").replace(/\n{3,}/g, "\n\n").trimEnd();
}

const collapseCommentBody = (body: string): string => {
  const trimmed = body.trim();
  if (trimmed.includes(COLLAPSE_MARKER)) {
    return trimmed;
  }
  return [
    COLLAPSE_MARKER,
    "<details>",
    `<summary>${COLLAPSE_SUMMARY}</summary>`,
    "",
    trimmed,
    "",
    "</details>",
  ]
    .join("\n")
    .replace(/\n{3,}/g, "\n\n")
    .trimEnd();
};

async function collapseOlderPreviewComments({
  octokit,
  owner,
  repo,
  prNumber,
  latestCommentId,
}: {
  octokit: Octokit;
  owner: string;
  repo: string;
  prNumber: number;
  latestCommentId: number;
}): Promise<void> {
  let collapsedCount = 0;
  const iterator = octokit.paginate.iterator(
    octokit.rest.issues.listComments,
    {
      owner,
      repo,
      issue_number: prNumber,
      per_page: 50,
    },
  );

      for await (const { data } of iterator) {
    for (const comment of data) {
      if (collapsedCount >= MAX_COMMENTS_TO_COLLAPSE) {
        return;
      }
      const { body } = comment;
      if (!body) continue;
      if (comment.id === latestCommentId) continue;
      const hasSignature = COMMENT_SIGNATURE_MATCHERS.some((signature) =>
        body.includes(signature),
      );
      if (!hasSignature) continue;

      const nextBody = collapseCommentBody(body);
      if (nextBody === body) continue;

      try {
        await octokit.rest.issues.updateComment({
          owner,
          repo,
          comment_id: comment.id,
          body: nextBody,
        });
        collapsedCount += 1;
        console.log("[github_pr_comments] Collapsed previous preview comment", {
          commentId: comment.id,
        });
      } catch (error) {
        console.error(
          "[github_pr_comments] Failed to collapse previous preview comment",
          {
            commentId: comment.id,
            error,
          },
        );
      }
    }
  }
}

export const addPrReaction = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    content: v.literal("eyes"),
  },
  handler: async (
    _ctx,
    { installationId, repoFullName, prNumber, content },
  ) => {
    try {
      const accessToken = await fetchInstallationAccessToken(installationId);
      if (!accessToken) {
        console.error(
          "[github_pr_comments] Failed to get access token for installation",
          { installationId },
        );
        return { ok: false, error: "Failed to get access token" };
      }

      const repo = parseRepoFullName(repoFullName);
      if (!repo) {
        console.error("[github_pr_comments] Invalid repo full name", {
          repoFullName,
        });
        return {
          ok: false,
          error: "Invalid repository name",
        };
      }

      const octokit = createOctokit(accessToken);
      const { data } = await octokit.rest.reactions.createForIssue({
        owner: repo.owner,
        repo: repo.repo,
        issue_number: prNumber,
        content,
      });

      console.log("[github_pr_comments] Successfully added reaction", {
        installationId,
        repoFullName,
        prNumber,
        reactionId: data.id,
      });

      return { ok: true, reactionId: data.id };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error adding reaction",
        {
          installationId,
          repoFullName,
          prNumber,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});

export const postPreviewComment = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    screenshotSetId: v.id("previewScreenshotSets"),
    previewRunId: v.id("previewRuns"),
  },
  handler: async (ctx, args) => {
    const { installationId, repoFullName, prNumber, screenshotSetId } = args;

    try {
      const accessToken = await fetchInstallationAccessToken(installationId);
      if (!accessToken) {
        console.error(
          "[github_pr_comments] Failed to get access token for preview comment",
          { installationId },
        );
        return { ok: false, error: "Failed to get access token" };
      }

      const repo = parseRepoFullName(repoFullName);
      if (!repo) {
        console.error("[github_pr_comments] Invalid repo full name", {
          repoFullName,
        });
        return { ok: false, error: "Invalid repository name" };
      }

      const octokit = createOctokit(accessToken);

      const previewRunPayload = await ctx.runQuery(
        internal.previewRuns.getRunWithConfig,
        { previewRunId: args.previewRunId },
      );
      const previewRun = previewRunPayload?.run;
      if (!previewRun) {
        console.error("[github_pr_comments] Preview run not found", {
          previewRunId: args.previewRunId,
        });
        return { ok: false, error: "Preview run not found" };
      }

      // Get screenshot set
      const screenshotSet = await ctx.runQuery(
        internal.previewScreenshots.getScreenshotSet,
        { screenshotSetId },
      );

      if (!screenshotSet) {
        console.error("[github_pr_comments] Screenshot set not found", {
          screenshotSetId,
        });
        return { ok: false, error: "Screenshot set not found" };
      }

      const prUrl =
        previewRun.prUrl ||
        `https://github.com/${repoFullName}/pull/${prNumber}`;
      let workspaceUrl: string | null = null;

      if (previewRun.taskRunId) {
        const taskRun = await ctx.runQuery(internal.taskRuns.getById, {
          id: previewRun.taskRunId as Id<"taskRuns">,
        });

        if (taskRun) {
          const team = await ctx.runQuery(
            internal.teams.getByTeamIdInternal,
            { teamId: taskRun.teamId },
          );
          const teamSlug = team?.slug ?? taskRun.teamId;
          workspaceUrl = `${CMUX_BASE_URL}/${teamSlug}/task/${taskRun.taskId}`;
        }
      }

      const prContext = await fetchPrContext({
        octokit,
        owner: repo.owner,
        repo: repo.repo,
        prNumber,
        commitSha: screenshotSet.commitSha,
      });

      const narrative = await generatePreviewNarrative({
        screenshotSet,
        prContext,
        prUrl,
        workspaceUrl,
      });

      // Collect previous screenshot sets for this PR so we can collapse them
      const previousRuns =
        (await ctx.runQuery(internal.previewRuns.listByConfigAndPr, {
          previewConfigId: previewRun.previewConfigId,
          prNumber: previewRun.prNumber,
          limit: MAX_PREVIOUS_SCREENSHOT_SETS + 1,
        })) ?? [];

      const previousSetEntries: Array<{
        run: PreviewRunDoc;
        set: ScreenshotSetDoc;
      }> = [];
      for (const run of previousRuns) {
        if (run._id === previewRun._id) continue;
        if (!run.screenshotSetId) continue;
        const priorSet = await ctx.runQuery(
          internal.previewScreenshots.getScreenshotSet,
          { screenshotSetId: run.screenshotSetId },
        );
        if (!priorSet) continue;
        previousSetEntries.push({ run, set: priorSet });
        if (previousSetEntries.length >= MAX_PREVIOUS_SCREENSHOT_SETS) {
          break;
        }
      }

      // Build comment body
      const latestHeading = `### Latest commit ${formatCommitLabel(screenshotSet)}`;
      const latestSection = await renderScreenshotSetMarkdown(
        ctx,
        screenshotSet,
        latestHeading,
        { prUrl, workspaceUrl, narrative },
      );

      const linksLine = formatReviewLinks({
        prUrl,
        workspaceUrl,
        workspaceLabel: "Open Workspace (expires in 30m)",
      });

      const commentSections: string[] = [];

      if (linksLine) {
        commentSections.push(linksLine);
      }

      commentSections.push("## Preview Screenshots", latestSection);

      if (previousSetEntries.length > 0) {
        const collapsedSections: string[] = [];
        for (const entry of previousSetEntries) {
          const sectionHeading = `#### ${summarizeSet(entry.set, entry.run)}`;
          collapsedSections.push(
            await renderScreenshotSetMarkdown(ctx, entry.set, sectionHeading, {
              prUrl,
              workspaceUrl,
              compact: true,
            }),
          );
        }

        const previousBlock = [
          "<details>",
          `<summary>Previous preview runs (${previousSetEntries.length})</summary>`,
          "",
          collapsedSections.join("\n\n---\n\n"),
          "",
          "</details>",
        ].join("\n");

        commentSections.push(previousBlock);
      }

      commentSections.push("---", COMMENT_SIGNATURE);
      const commentBody = commentSections.join("\n\n");

      // Post comment to GitHub
      const { data } = await octokit.rest.issues.createComment({
        owner: repo.owner,
        repo: repo.repo,
        issue_number: prNumber,
        body: commentBody,
      });

      console.log("[github_pr_comments] Successfully posted preview comment", {
        installationId,
        repoFullName,
        prNumber,
        commentId: data.id,
        commentUrl: data.html_url,
      });

      // Update preview run with comment URL
      if (data.html_url) {
        await ctx.runMutation(internal.previewRuns.updateStatus, {
          previewRunId: args.previewRunId,
          status: "completed",
          screenshotSetId,
          githubCommentUrl: data.html_url,
          githubCommentId: data.id,
        });
      }

      await collapseOlderPreviewComments({
        octokit,
        owner: repo.owner,
        repo: repo.repo,
        prNumber,
        latestCommentId: data.id,
      });

      return { ok: true, commentId: data.id, commentUrl: data.html_url };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error posting preview comment",
        {
          installationId,
          repoFullName,
          prNumber,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});

export const addPrComment = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    body: v.string(),
  },
  handler: async (
    _ctx,
    { installationId, repoFullName, prNumber, body },
  ) => {
    try {
      const accessToken = await fetchInstallationAccessToken(installationId);
      if (!accessToken) {
        console.error(
          "[github_pr_comments] Failed to get access token for installation",
          { installationId },
        );
        return { ok: false, error: "Failed to get access token" };
      }

      const repo = parseRepoFullName(repoFullName);
      if (!repo) {
        console.error("[github_pr_comments] Invalid repo full name", {
          repoFullName,
        });
        return { ok: false, error: "Invalid repository name" };
      }

      const octokit = createOctokit(accessToken);
      const { data } = await octokit.rest.issues.createComment({
        owner: repo.owner,
        repo: repo.repo,
        issue_number: prNumber,
        body,
      });
      console.log("[github_pr_comments] Successfully added comment", {
        installationId,
        repoFullName,
        prNumber,
        commentId: data.id,
      });

      return { ok: true, commentId: data.id };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error adding comment",
        {
          installationId,
          repoFullName,
          prNumber,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});

async function getScreenshotsForPr(
  ctx: ActionCtx,
  {
    teamId,
    repoFullName,
    prNumber,
  }: {
    teamId: string;
    repoFullName: string;
    prNumber: number;
  },
): Promise<Array<{ url: string; fileName?: string }>> {
  try {
    // Find task runs that have this PR
    const taskRuns = await ctx.runQuery(
      internal.github_pr_queries.findTaskRunsForPr,
      {
        teamId,
        repoFullName,
        prNumber,
      },
    );

    if (taskRuns.length === 0) {
      return [];
    }

    // Get screenshots from the latest task run
    const screenshots: Array<{ url: string; fileName?: string }> = [];

    for (const run of taskRuns) {
      if (run.latestScreenshotSetId) {
        const screenshotSet = await ctx.runQuery(
          internal.github_pr_queries.getScreenshotSet,
          {
            screenshotSetId: run.latestScreenshotSetId,
          },
        );

        if (screenshotSet && screenshotSet.status === "completed") {
          for (const image of screenshotSet.images) {
            if (image.url) {
              screenshots.push({
                url: image.url,
                fileName: image.fileName,
              });
            }
          }
        }
      }
    }

    return screenshots;
  } catch (error) {
    console.error(
      "[github_pr_comments] Error fetching screenshots for PR",
      {
        teamId,
        repoFullName,
        prNumber,
        error,
      },
    );
    return [];
  }
}

function formatScreenshotComment(
  screenshots: Array<{ url: string; fileName?: string }>,
): string {
  if (screenshots.length === 0) {
    return "";
  }

  let markdown = "## Screenshots\n\n";
  markdown +=
    "Here are the screenshots from the latest run:\n\n";

  for (const screenshot of screenshots) {
    const title = screenshot.fileName || "Screenshot";
    markdown += `### ${title}\n\n`;
    markdown += `![${title}](${screenshot.url})\n\n`;
  }

  return markdown;
}

export const postPreviewCommentWithTaskScreenshots = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    taskRunId: v.id("taskRuns"),
    previewRunId: v.id("previewRuns"),
  },
  handler: async (ctx, args): Promise<{ ok: true; commentId?: number; commentUrl?: string } | { ok: false; error: string }> => {
    const { installationId, repoFullName, prNumber, taskRunId, previewRunId } = args;

    try {
      const accessToken = await fetchInstallationAccessToken(installationId);
      if (!accessToken) {
        console.error(
          "[github_pr_comments] Failed to get access token for preview comment",
          { installationId },
        );
        return { ok: false, error: "Failed to get access token" };
      }

      const repo = parseRepoFullName(repoFullName);
      if (!repo) {
        console.error("[github_pr_comments] Invalid repo full name", {
          repoFullName,
        });
        return { ok: false, error: "Invalid repository name" };
      }

      const octokit = createOctokit(accessToken);

      // Get task run to find screenshot set
      const taskRun = await ctx.runQuery(internal.taskRuns.getById, {
        id: taskRunId,
      });

      if (!taskRun?.latestScreenshotSetId) {
        console.error("[github_pr_comments] No screenshot set for task run", {
          taskRunId,
        });
        return { ok: false, error: "No screenshot set found" };
      }

      const previewRun = await ctx.runQuery(internal.previewRuns.getById, {
        id: previewRunId,
      });

      if (!previewRun) {
        console.error("[github_pr_comments] Preview run not found", {
          previewRunId,
        });
        return { ok: false, error: "Preview run not found" };
      }

      // Get team info for the URL
      const team = await ctx.runQuery(internal.teams.getByTeamIdInternal, {
        teamId: taskRun.teamId,
      });
      const teamSlug: string = team?.slug ?? taskRun.teamId;
      const workspaceUrl: string = `${CMUX_BASE_URL}/${teamSlug}/task/${taskRun.taskId}`;
      const prUrl = `https://github.com/${repoFullName}/pull/${prNumber}`;

      // Get screenshot set from task run
      const screenshotSet = await ctx.runQuery(
        internal.github_pr_queries.getScreenshotSet,
        { screenshotSetId: taskRun.latestScreenshotSetId },
      );

      if (!screenshotSet) {
        console.error("[github_pr_comments] Screenshot set not found", {
          screenshotSetId: taskRun.latestScreenshotSetId,
        });
        return { ok: false, error: "Screenshot set not found" };
      }

      const prContext = await fetchPrContext({
        octokit,
        owner: repo.owner,
        repo: repo.repo,
        prNumber,
        commitSha: screenshotSet.commitSha,
      });

      const renderableSet: RenderableScreenshotSet = {
        status: screenshotSet.status as ScreenshotSetDoc["status"],
        commitSha: screenshotSet.commitSha,
        capturedAt: screenshotSet.capturedAt,
        error: screenshotSet.error,
        images: screenshotSet.images.map((image) => ({
          storageId: image.storageId as Id<"_storage">,
          mimeType: image.mimeType,
          fileName: image.fileName,
          commitSha: image.commitSha,
          width: (image as { width?: number }).width,
          height: (image as { height?: number }).height,
        })),
      };

      const narrative = await generatePreviewNarrative({
        screenshotSet: renderableSet,
        prContext,
        prUrl,
        workspaceUrl,
      });

      const linksLine = formatReviewLinks({
        prUrl,
        workspaceUrl,
        workspaceLabel: "Open Workspace (expires in 30m)",
      });
      const reviewSection = await renderScreenshotSetMarkdown(
        ctx,
        renderableSet,
        "## Preview Story",
        { prUrl, workspaceUrl, narrative },
      );

      const commentBody = [linksLine, reviewSection, "---", PREVIEW_SIGNATURE]
        .filter(Boolean)
        .join("\n\n");

      // Post comment to GitHub
      const { data } = await octokit.rest.issues.createComment({
        owner: repo.owner,
        repo: repo.repo,
        issue_number: prNumber,
        body: commentBody,
      });
      console.log("[github_pr_comments] Successfully posted preview comment", {
        installationId,
        repoFullName,
        prNumber,
        commentId: data.id,
        commentUrl: data.html_url,
      });

      const previewScreenshotSetId = await ctx.runMutation(
        internal.previewScreenshots.createScreenshotSet,
        {
          previewRunId,
          status: screenshotSet.status as "completed" | "failed" | "skipped",
          commitSha: screenshotSet.commitSha ?? previewRun.headSha,
          error: screenshotSet.error,
          images: screenshotSet.images.map((image) => ({
            storageId: image.storageId as Id<"_storage">,
            mimeType: image.mimeType,
            fileName: image.fileName,
            commitSha: image.commitSha,
          })),
        },
      );

      // Update preview run with comment URL
      if (data.html_url) {
        await ctx.runMutation(internal.previewRuns.updateStatus, {
          previewRunId,
          status: screenshotSet.status as "completed" | "failed" | "skipped",
          stateReason: screenshotSet.error,
          screenshotSetId: previewScreenshotSetId,
          githubCommentUrl: data.html_url,
        });
      }

      return { ok: true, commentId: data.id, commentUrl: data.html_url };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error posting preview comment",
        {
          installationId,
          repoFullName,
          prNumber,
          taskRunId,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});

export const addScreenshotCommentToPr = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    teamId: v.string(),
  },
  handler: async (
    ctx,
    { installationId, repoFullName, prNumber, teamId },
  ): Promise<
    | { ok: true; commentId?: number; skipped?: boolean; reason?: string }
    | { ok: false; error: string }
  > => {
    try {
      const screenshots = await getScreenshotsForPr(ctx, {
        teamId,
        repoFullName,
        prNumber,
      });

      if (screenshots.length === 0) {
        console.log(
          "[github_pr_comments] No screenshots found for PR",
          {
            installationId,
            repoFullName,
            prNumber,
          },
        );
        return { ok: true, skipped: true, reason: "No screenshots found" };
      }

      const body = formatScreenshotComment(screenshots);

      const result = await ctx.runAction(internal.github_pr_comments.addPrComment, {
        installationId,
        repoFullName,
        prNumber,
        body,
      });

      if (result.ok) {
        return { ok: true, commentId: result.commentId };
      }

      return { ok: false, error: result?.error ?? "Unknown error" };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error adding screenshot comment",
        {
          installationId,
          repoFullName,
          prNumber,
          teamId,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});
